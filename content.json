{"meta":{"title":"🥔🍅","subtitle":"","description":"","author":"jagaimotomato","url":"https://jagaimotomato.space","root":"/"},"pages":[{"title":"关于我","date":"2023-03-05T13:26:03.102Z","updated":"2023-03-05T13:26:03.102Z","comments":true,"path":"about.html","permalink":"https://jagaimotomato.space/about.html","excerpt":"","text":"名字 jagaimotomato 性格 内向，社恐 缺点 反应迟钝，后知后觉，记忆力差 最爱的番剧 进击的巨人 爱好 写代码，看番剧 爱吃 土豆，番茄 目标 find vinland"},{"title":"文章归档","date":"2023-03-05T10:51:25.422Z","updated":"2023-03-05T10:51:25.422Z","comments":true,"path":"archive.html","permalink":"https://jagaimotomato.space/archive.html","excerpt":"","text":""},{"title":"","date":"2023-03-05T10:51:25.423Z","updated":"2023-03-05T10:51:25.423Z","comments":true,"path":"custom.css","permalink":"https://jagaimotomato.space/custom.css","excerpt":"","text":".nexmoe-avatar img:hover { animation: avatar 0.8s linear 0s; } @keyframes avatar { 0% { transform: scale(1.2) rotateZ(3deg); animation-timing-function: ease-in; } 12.5% { transform: scale(1.2) rotateZ(-3deg) } 25% { transform: scale(1.2) rotateZ(3deg) } 37.5% { transform: scale(1.2) rotateZ(-3deg) } 50% { transform: scale(1.2) rotateZ(3deg); animation-timing-function: ease-out; } 62.5% { transform: scale(1.2) rotateZ(-3deg) } 75% { transform: scale(1.2) rotateZ(3deg) } 87.5% { transform: scale(1.2) rotateZ(-3deg) } }"},{"title":"赞助","date":"2023-03-05T13:42:36.154Z","updated":"2023-03-05T13:42:36.154Z","comments":true,"path":"donate.html","permalink":"https://jagaimotomato.space/donate.html","excerpt":"","text":"Vme 50 请我吃肯德基"},{"title":"朋友","date":"2013-07-13T12:46:25.000Z","updated":"2023-03-05T13:43:08.737Z","comments":true,"path":"PY.html","permalink":"https://jagaimotomato.space/PY.html","excerpt":"","text":"留言添加友链"},{"title":"关于jagaimotomato","date":"2022-08-01T11:11:38.000Z","updated":"2023-03-05T10:51:25.422Z","comments":true,"path":"about/index.html","permalink":"https://jagaimotomato.space/about/index.html","excerpt":"","text":"一切从这里开始"},{"title":"分类","date":"2022-08-01T08:13:57.000Z","updated":"2023-03-05T10:51:25.423Z","comments":true,"path":"categories/index.html","permalink":"https://jagaimotomato.space/categories/index.html","excerpt":"","text":""},{"title":"链接","date":"2022-08-01T08:13:57.000Z","updated":"2023-03-05T10:51:25.435Z","comments":true,"path":"link/index.html","permalink":"https://jagaimotomato.space/link/index.html","excerpt":"","text":"收藏的链接前端 素材 罫線・飾り罫ライン素材 FREE LINE DESIGN 工具 W3Schools Free Online Web Tutorials"},{"title":"标签","date":"2022-08-01T08:13:57.000Z","updated":"2023-03-05T10:51:25.435Z","comments":true,"path":"tags/index.html","permalink":"https://jagaimotomato.space/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"螺蛳粉火锅","slug":"20230304-朴素一餐","date":"2023-03-04T13:00:00.000Z","updated":"2023-03-05T13:28:13.799Z","comments":true,"path":"2023/03/04/20230304-朴素一餐/","link":"","permalink":"https://jagaimotomato.space/2023/03/04/20230304-%E6%9C%B4%E7%B4%A0%E4%B8%80%E9%A4%90/","excerpt":"","text":"今日与友人Z去吃螺蛳粉火锅，solo 6(me) 4(Z) 开，剩下个大企鹅跳水跟几个包子状的包子没有吃。ps：吃到一半才想起来拍照 辣 臭 好吃","categories":[{"name":"日常","slug":"日常","permalink":"https://jagaimotomato.space/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"朴素一餐","slug":"朴素一餐","permalink":"https://jagaimotomato.space/tags/%E6%9C%B4%E7%B4%A0%E4%B8%80%E9%A4%90/"},{"name":"友人Z","slug":"友人Z","permalink":"https://jagaimotomato.space/tags/%E5%8F%8B%E4%BA%BAZ/"}]},{"title":"今天情人节","slug":"20230214","date":"2023-02-14T13:06:00.000Z","updated":"2023-03-05T13:09:32.999Z","comments":true,"path":"2023/02/14/20230214/","link":"","permalink":"https://jagaimotomato.space/2023/02/14/20230214/","excerpt":"","text":"跟我没有关系","categories":[{"name":"日常","slug":"日常","permalink":"https://jagaimotomato.space/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"灌水","slug":"灌水","permalink":"https://jagaimotomato.space/tags/%E7%81%8C%E6%B0%B4/"}]},{"title":"leetcode","slug":"leetcode","date":"2022-08-06T13:19:37.000Z","updated":"2023-03-05T10:51:25.421Z","comments":true,"path":"2022/08/06/leetcode/","link":"","permalink":"https://jagaimotomato.space/2022/08/06/leetcode/","excerpt":"","text":"两数之和 给定一个整数数组nums和一个整数目标值target，请你在该数组中找出和为目标值的那两个整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 你可以按任意顺序返回答案。 输入：nums &#x3D; [2,7,11,15], target &#x3D; 9输出：[0,1]解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。 my answer 最佳解法 两数相加 给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。请你将两个数相加，并以相同形式返回一个表示和的链表。 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例1 123输入：l1 = [2,4,3], l2 = [5,6,4]输出：[7,0,8]解释：342 + 465 = 807. 示例212输入：l1 = [0], l2 = [0]输出：[0] 示例312输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]输出：[8,9,9,9,0,0,0,1] 提示 每个链表中的节点数在范围 [1, 100] 内 0 &lt;&#x3D; Node.val &lt;&#x3D; 9 题目数据保证列表表示的数字不含前导零 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199package mainimport ( &quot;fmt&quot;)// leetcode02 两数相加 -- 链表type node struct &#123; value interface&#123;&#125; prev *node next *node&#125;type linkedList struct &#123; head *node tail *node length int&#125;func NewLinkedList() *linkedList &#123; return &amp;linkedList&#123; length: 0, head: nil, tail: nil, &#125;&#125;func (l *linkedList) Size() int &#123; return l.length&#125;func (l *linkedList) IsEmpty() bool &#123; return l.Size() == 0&#125;func (l *linkedList) push(value interface&#123;&#125;) &#123; n := node&#123; prev: l.tail, next: nil, value: value, &#125; if l.tail == nil &#123; l.head, l.tail = &amp;n, &amp;n &#125; else &#123; l.tail.next = &amp;n l.tail = &amp;n &#125; l.length++&#125;func (l *linkedList) Insert(index int, value interface&#123;&#125;) error &#123; size := l.Size() if index &lt; 0 || index &gt; size &#123; return fmt.Errorf(&quot;index out of range, index:%d, len:%d&quot;, index, size) &#125; if index == size &#123; l.push(value) &#125; else &#123; l.linkBefore(value, l.getElement(index)) &#125; return nil&#125;// linkBefore inserts val before non-null element e.func (l *linkedList) linkBefore(value interface&#123;&#125;, n *node) &#123; newElement := node&#123; prev: nil, next: n, value: value, &#125; if n != nil &#123; newElement.prev = n.prev if n.prev != nil &#123; n.prev.next = &amp;newElement &#125; else &#123; l.head = &amp;newElement &#125; n.prev = &amp;newElement &#125; else &#123; l.head, l.tail = &amp;newElement, &amp;newElement &#125; l.length++&#125;func (l *linkedList) getElement(index int) *node &#123; size := l.Size() var n *node if index &lt; (size &gt;&gt; 1) &#123; n = l.head for i := 0; i &lt; index; i++ &#123; n = n.next &#125; &#125; else &#123; n = l.tail for i := size - 1; i &gt; index ; i-- &#123; n = n.prev &#125; &#125; return n&#125;func (l *linkedList) Remove(index int) (interface&#123;&#125;, error) &#123; size := l.Size() if index &lt; 0 || index &gt;= size &#123; return nil, fmt.Errorf(&quot;index out of range, index:%d, len:%d&quot;, index, size) &#125; return l.unlink(l.getElement(index)), nil&#125;// unlink removes the specified element e in this list.func (l *linkedList) unlink(n *node) interface&#123;&#125; &#123; if nil == n &#123; return nil &#125; retValue := n.value if nil == n.prev &#123; l.head = n.next &#125; else &#123; n.prev.next = n.next &#125; if nil == n.next &#123; l.tail = n.prev &#125; else &#123; n.next.prev = n.prev &#125; n.prev, n.next, n.value = nil, nil, nil l.length-- return retValue&#125;func (l *linkedList) Iterator() (func() (interface&#123;&#125;, bool), bool) &#123; n := l.head return func() (interface&#123;&#125;, bool) &#123; var element interface&#123;&#125; if n != nil &#123; element = n.value n = n.next &#125; else &#123; element = nil &#125; return element, n != nil &#125;, n != nil&#125;func (ll *linkedList) Get(index int) (interface&#123;&#125;, error) &#123; size := ll.Size() if index &lt; 0 || index &gt;= size &#123; return nil, fmt.Errorf(&quot;index out of range, index:%d, len:%d&quot;, index, size) &#125; return ll.getElement(index).value, nil&#125;func main() &#123; first := NewLinkedList() first.push(2) first.push(4) first.push(3) second := NewLinkedList() second.push(5) second.push(6) second.push(4) size := first.Size() newLL := NewLinkedList() var current, ten int for i := 0; i &lt; size; i++ &#123; firstV, _ := first.Get(i) secondV, _ := second.Get(i) sum := firstV.(int) + secondV.(int) if ten != 0 &#123; sum += ten ten = 0 &#125; if sum &gt;= 10 &#123; current = sum % 10 ten = sum / 10 &#125; else &#123; current = sum &#125; newLL.push(current) &#125; if ten != 0 &#123; newLL.push(ten) &#125; it, hasNext := newLL.Iterator() var v interface&#123;&#125; for hasNext &#123; v, hasNext = it() fmt.Printf(&quot; Value: %v\\n&quot;, v) &#125;&#125; 无重复字符的最长子串给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 输入: s &#x3D; “abcabcbb”输出: 3解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。示例 2: 输入: s &#x3D; “bbbbb”输出: 1解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。示例 3: 输入: s &#x3D; “pwwkew”输出: 3解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。 提示： 0 &lt;&#x3D; s.length &lt;&#x3D; 5 * 104s 由英文字母、数字、符号和空格组成 123456789101112131415161718192021222324252627282930313233package main// 找出无重复 最长子串func solution(str string) int &#123; if len(str) == 0 &#123; return 0 &#125; strMap := make(map[string]int) var ( max int left int ) for i := 0; i &lt; len(str); i++ &#123; if value, ok := strMap[string(str[i])]; ok &#123; // i=3 4 5 left = compare(left, value + 1) // value=0 left=1 left=2 left=3 &#125; strMap[string(str[i])] = i // 0 a-0 1 b-1 c-2 i=6 d-6 max = compare(max, i - left + 1)// 1 2 3 4 &#125; return max&#125;func compare(a, b int) int &#123; if a &gt; b &#123; return a &#125; else &#123; return b &#125;&#125;func main() &#123; const name = &quot;abcabcd&quot; solution(name)&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://jagaimotomato.space/categories/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"算法/leetcode","permalink":"https://jagaimotomato.space/categories/%E7%AE%97%E6%B3%95/leetcode/"},{"name":"js","slug":"js","permalink":"https://jagaimotomato.space/categories/js/"}],"tags":[]},{"title":"npm","slug":"npm","date":"2022-08-06T07:17:23.000Z","updated":"2023-03-05T10:51:25.422Z","comments":true,"path":"2022/08/06/npm/","link":"","permalink":"https://jagaimotomato.space/2022/08/06/npm/","excerpt":"","text":"设置npm config set registry links npm config set registry https://npmmirror.com/mirrors/ npm初始registry：https://registry.npmjs.org/ npm config set registry https://registry.npmjs.org/ 开源镜像: https://npmmirror.com/mirrors/Node.js 镜像: https://npmmirror.com/mirrors/node/alinode 镜像: https://npmmirror.com/mirrors/alinode/ChromeDriver 镜像: https://npmmirror.com/mirrors/chromedriver/OperaDriver 镜像: https://npmmirror.com/mirrors/operadriver/Selenium 镜像: https://npmmirror.com/mirrors/selenium/electron 镜像: https://npmmirror.com/mirrors/electron/","categories":[{"name":"frontend","slug":"frontend","permalink":"https://jagaimotomato.space/categories/frontend/"},{"name":"包管理工具","slug":"frontend/包管理工具","permalink":"https://jagaimotomato.space/categories/frontend/%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"npm","slug":"npm","permalink":"https://jagaimotomato.space/tags/npm/"}]},{"title":"几种经典数组排序方法","slug":"几种经典数组排序方法","date":"2022-08-02T03:58:44.000Z","updated":"2023-03-05T10:51:25.422Z","comments":true,"path":"2022/08/02/几种经典数组排序方法/","link":"","permalink":"https://jagaimotomato.space/2022/08/02/%E5%87%A0%E7%A7%8D%E7%BB%8F%E5%85%B8%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95/","excerpt":"","text":"冒泡排序 选择排序 插入排序 对于基本有序的数组最好用 稳定 希尔排序 优化版插排 归并排序 快速排序 排序时间复杂度","categories":[{"name":"算法","slug":"算法","permalink":"https://jagaimotomato.space/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"js","slug":"js","permalink":"https://jagaimotomato.space/tags/js/"}]},{"title":"hello world","slug":"post-test","date":"2022-08-01T08:13:57.000Z","updated":"2023-03-05T12:31:18.102Z","comments":true,"path":"2022/08/01/post-test/","link":"","permalink":"https://jagaimotomato.space/2022/08/01/post-test/","excerpt":"","text":"我的博客开张啦","categories":[{"name":"日常","slug":"日常","permalink":"https://jagaimotomato.space/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"灌水","slug":"灌水","permalink":"https://jagaimotomato.space/tags/%E7%81%8C%E6%B0%B4/"}]}],"categories":[{"name":"日常","slug":"日常","permalink":"https://jagaimotomato.space/categories/%E6%97%A5%E5%B8%B8/"},{"name":"算法","slug":"算法","permalink":"https://jagaimotomato.space/categories/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"算法/leetcode","permalink":"https://jagaimotomato.space/categories/%E7%AE%97%E6%B3%95/leetcode/"},{"name":"js","slug":"js","permalink":"https://jagaimotomato.space/categories/js/"},{"name":"frontend","slug":"frontend","permalink":"https://jagaimotomato.space/categories/frontend/"},{"name":"包管理工具","slug":"frontend/包管理工具","permalink":"https://jagaimotomato.space/categories/frontend/%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"朴素一餐","slug":"朴素一餐","permalink":"https://jagaimotomato.space/tags/%E6%9C%B4%E7%B4%A0%E4%B8%80%E9%A4%90/"},{"name":"友人Z","slug":"友人Z","permalink":"https://jagaimotomato.space/tags/%E5%8F%8B%E4%BA%BAZ/"},{"name":"灌水","slug":"灌水","permalink":"https://jagaimotomato.space/tags/%E7%81%8C%E6%B0%B4/"},{"name":"npm","slug":"npm","permalink":"https://jagaimotomato.space/tags/npm/"},{"name":"js","slug":"js","permalink":"https://jagaimotomato.space/tags/js/"}]}