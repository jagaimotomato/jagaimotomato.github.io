{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"关于jagaimotomato","date":"2022-08-01T11:11:38.000Z","updated":"2022-08-01T14:49:05.515Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"一切从这里开始"},{"title":"链接","date":"2022-08-01T08:13:57.000Z","updated":"2022-08-04T08:55:06.904Z","comments":true,"path":"link/index.html","permalink":"http://example.com/link/index.html","excerpt":"","text":"收藏的链接前端 素材 罫線・飾り罫ライン素材 FREE LINE DESIGN 工具 W3Schools Free Online Web Tutorials"},{"title":"分类","date":"2022-08-01T08:13:57.000Z","updated":"2022-08-01T11:10:00.679Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-08-01T08:13:57.000Z","updated":"2022-08-01T11:10:00.642Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"文章归档","date":"2023-02-11T14:43:48.581Z","updated":"2023-02-11T14:41:50.658Z","comments":true,"path":"archive.html","permalink":"http://example.com/archive.html","excerpt":"","text":""},{"title":"links","date":"2013-07-13T12:46:25.000Z","updated":"2023-02-11T14:44:41.987Z","comments":true,"path":"PY.html","permalink":"http://example.com/PY.html","excerpt":"","text":""}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2023-02-02T13:51:37.777Z","updated":"2023-02-12T08:44:06.881Z","comments":true,"path":"2023/02/02/hello-world/","link":"","permalink":"http://example.com/2023/02/02/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"leetcode","slug":"leetcode","date":"2022-08-06T13:19:37.000Z","updated":"2022-09-25T15:00:59.122Z","comments":true,"path":"2022/08/06/leetcode/","link":"","permalink":"http://example.com/2022/08/06/leetcode/","excerpt":"","text":"两数之和 给定一个整数数组nums和一个整数目标值target，请你在该数组中找出和为目标值的那两个整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 你可以按任意顺序返回答案。 输入：nums &#x3D; [2,7,11,15], target &#x3D; 9输出：[0,1]解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。 my answer 最佳解法 两数相加 给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。请你将两个数相加，并以相同形式返回一个表示和的链表。 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例1 123输入：l1 = [2,4,3], l2 = [5,6,4]输出：[7,0,8]解释：342 + 465 = 807. 示例212输入：l1 = [0], l2 = [0]输出：[0] 示例312输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]输出：[8,9,9,9,0,0,0,1] 提示 每个链表中的节点数在范围 [1, 100] 内 0 &lt;&#x3D; Node.val &lt;&#x3D; 9 题目数据保证列表表示的数字不含前导零 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199package mainimport ( &quot;fmt&quot;)// leetcode02 两数相加 -- 链表type node struct &#123; value interface&#123;&#125; prev *node next *node&#125;type linkedList struct &#123; head *node tail *node length int&#125;func NewLinkedList() *linkedList &#123; return &amp;linkedList&#123; length: 0, head: nil, tail: nil, &#125;&#125;func (l *linkedList) Size() int &#123; return l.length&#125;func (l *linkedList) IsEmpty() bool &#123; return l.Size() == 0&#125;func (l *linkedList) push(value interface&#123;&#125;) &#123; n := node&#123; prev: l.tail, next: nil, value: value, &#125; if l.tail == nil &#123; l.head, l.tail = &amp;n, &amp;n &#125; else &#123; l.tail.next = &amp;n l.tail = &amp;n &#125; l.length++&#125;func (l *linkedList) Insert(index int, value interface&#123;&#125;) error &#123; size := l.Size() if index &lt; 0 || index &gt; size &#123; return fmt.Errorf(&quot;index out of range, index:%d, len:%d&quot;, index, size) &#125; if index == size &#123; l.push(value) &#125; else &#123; l.linkBefore(value, l.getElement(index)) &#125; return nil&#125;// linkBefore inserts val before non-null element e.func (l *linkedList) linkBefore(value interface&#123;&#125;, n *node) &#123; newElement := node&#123; prev: nil, next: n, value: value, &#125; if n != nil &#123; newElement.prev = n.prev if n.prev != nil &#123; n.prev.next = &amp;newElement &#125; else &#123; l.head = &amp;newElement &#125; n.prev = &amp;newElement &#125; else &#123; l.head, l.tail = &amp;newElement, &amp;newElement &#125; l.length++&#125;func (l *linkedList) getElement(index int) *node &#123; size := l.Size() var n *node if index &lt; (size &gt;&gt; 1) &#123; n = l.head for i := 0; i &lt; index; i++ &#123; n = n.next &#125; &#125; else &#123; n = l.tail for i := size - 1; i &gt; index ; i-- &#123; n = n.prev &#125; &#125; return n&#125;func (l *linkedList) Remove(index int) (interface&#123;&#125;, error) &#123; size := l.Size() if index &lt; 0 || index &gt;= size &#123; return nil, fmt.Errorf(&quot;index out of range, index:%d, len:%d&quot;, index, size) &#125; return l.unlink(l.getElement(index)), nil&#125;// unlink removes the specified element e in this list.func (l *linkedList) unlink(n *node) interface&#123;&#125; &#123; if nil == n &#123; return nil &#125; retValue := n.value if nil == n.prev &#123; l.head = n.next &#125; else &#123; n.prev.next = n.next &#125; if nil == n.next &#123; l.tail = n.prev &#125; else &#123; n.next.prev = n.prev &#125; n.prev, n.next, n.value = nil, nil, nil l.length-- return retValue&#125;func (l *linkedList) Iterator() (func() (interface&#123;&#125;, bool), bool) &#123; n := l.head return func() (interface&#123;&#125;, bool) &#123; var element interface&#123;&#125; if n != nil &#123; element = n.value n = n.next &#125; else &#123; element = nil &#125; return element, n != nil &#125;, n != nil&#125;func (ll *linkedList) Get(index int) (interface&#123;&#125;, error) &#123; size := ll.Size() if index &lt; 0 || index &gt;= size &#123; return nil, fmt.Errorf(&quot;index out of range, index:%d, len:%d&quot;, index, size) &#125; return ll.getElement(index).value, nil&#125;func main() &#123; first := NewLinkedList() first.push(2) first.push(4) first.push(3) second := NewLinkedList() second.push(5) second.push(6) second.push(4) size := first.Size() newLL := NewLinkedList() var current, ten int for i := 0; i &lt; size; i++ &#123; firstV, _ := first.Get(i) secondV, _ := second.Get(i) sum := firstV.(int) + secondV.(int) if ten != 0 &#123; sum += ten ten = 0 &#125; if sum &gt;= 10 &#123; current = sum % 10 ten = sum / 10 &#125; else &#123; current = sum &#125; newLL.push(current) &#125; if ten != 0 &#123; newLL.push(ten) &#125; it, hasNext := newLL.Iterator() var v interface&#123;&#125; for hasNext &#123; v, hasNext = it() fmt.Printf(&quot; Value: %v\\n&quot;, v) &#125;&#125; 无重复字符的最长子串给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 输入: s &#x3D; “abcabcbb”输出: 3解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。示例 2: 输入: s &#x3D; “bbbbb”输出: 1解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。示例 3: 输入: s &#x3D; “pwwkew”输出: 3解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。 提示： 0 &lt;&#x3D; s.length &lt;&#x3D; 5 * 104s 由英文字母、数字、符号和空格组成 123456789101112131415161718192021222324252627282930313233package main// 找出无重复 最长子串func solution(str string) int &#123; if len(str) == 0 &#123; return 0 &#125; strMap := make(map[string]int) var ( max int left int ) for i := 0; i &lt; len(str); i++ &#123; if value, ok := strMap[string(str[i])]; ok &#123; // i=3 4 5 left = compare(left, value + 1) // value=0 left=1 left=2 left=3 &#125; strMap[string(str[i])] = i // 0 a-0 1 b-1 c-2 i=6 d-6 max = compare(max, i - left + 1)// 1 2 3 4 &#125; return max&#125;func compare(a, b int) int &#123; if a &gt; b &#123; return a &#125; else &#123; return b &#125;&#125;func main() &#123; const name = &quot;abcabcd&quot; solution(name)&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"算法/leetcode","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/leetcode/"},{"name":"js","slug":"js","permalink":"http://example.com/categories/js/"}],"tags":[]},{"title":"npm","slug":"npm","date":"2022-08-06T07:17:23.000Z","updated":"2022-08-06T07:49:41.763Z","comments":true,"path":"2022/08/06/npm/","link":"","permalink":"http://example.com/2022/08/06/npm/","excerpt":"","text":"设置npm config set registry links npm config set registry https://npmmirror.com/mirrors/ npm初始registry：https://registry.npmjs.org/ npm config set registry https://registry.npmjs.org/ 开源镜像: https://npmmirror.com/mirrors/Node.js 镜像: https://npmmirror.com/mirrors/node/alinode 镜像: https://npmmirror.com/mirrors/alinode/ChromeDriver 镜像: https://npmmirror.com/mirrors/chromedriver/OperaDriver 镜像: https://npmmirror.com/mirrors/operadriver/Selenium 镜像: https://npmmirror.com/mirrors/selenium/electron 镜像: https://npmmirror.com/mirrors/electron/","categories":[{"name":"frontend","slug":"frontend","permalink":"http://example.com/categories/frontend/"},{"name":"包管理工具","slug":"frontend/包管理工具","permalink":"http://example.com/categories/frontend/%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"npm","slug":"npm","permalink":"http://example.com/tags/npm/"}]},{"title":"几种经典数组排序方法","slug":"几种经典数组排序方法","date":"2022-08-02T03:58:44.000Z","updated":"2022-08-05T13:02:07.462Z","comments":true,"path":"2022/08/02/几种经典数组排序方法/","link":"","permalink":"http://example.com/2022/08/02/%E5%87%A0%E7%A7%8D%E7%BB%8F%E5%85%B8%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95/","excerpt":"","text":"冒泡排序 选择排序 插入排序 对于基本有序的数组最好用 稳定 希尔排序 优化版插排 归并排序 快速排序 排序时间复杂度","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"}]},{"title":"第一篇blog","slug":"post-test","date":"2022-08-01T08:13:57.000Z","updated":"2022-08-05T13:03:18.719Z","comments":true,"path":"2022/08/01/post-test/","link":"","permalink":"http://example.com/2022/08/01/post-test/","excerpt":"","text":"我的博客开张啦","categories":[{"name":"日常","slug":"日常","permalink":"http://example.com/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"第一篇","slug":"第一篇","permalink":"http://example.com/tags/%E7%AC%AC%E4%B8%80%E7%AF%87/"}]}],"categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"算法/leetcode","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/leetcode/"},{"name":"js","slug":"js","permalink":"http://example.com/categories/js/"},{"name":"frontend","slug":"frontend","permalink":"http://example.com/categories/frontend/"},{"name":"包管理工具","slug":"frontend/包管理工具","permalink":"http://example.com/categories/frontend/%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"},{"name":"日常","slug":"日常","permalink":"http://example.com/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"npm","slug":"npm","permalink":"http://example.com/tags/npm/"},{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"},{"name":"第一篇","slug":"第一篇","permalink":"http://example.com/tags/%E7%AC%AC%E4%B8%80%E7%AF%87/"}]}